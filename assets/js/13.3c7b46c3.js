(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{490:function(t,n,r){"use strict";r.r(n);var e=r(4),o=Object(e.a)({},(function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("经历过对Vue源码的分析历程，才发现针对于源码的分析过程，最好的方法莫过于将整体拆分成几块，再按照次序或联系仔细分析小的模块，最后再将其汇总串联起来整体过一遍。这种方式的好处在于学的透彻学的精细，但是难点在于开头的拆分，除非找到很好的教程帮助分析否则会浪费很多时间。\n这次对于VueRouter的分析，得益于一篇"),r("a",{attrs:{href:"https://segmentfault.com/a/1190000020245449?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[t._v("很好的教程"),r("OutboundLink")],1),t._v(",使我在拆分源码时候少做了很多的无用功，本篇的大纲部分与教程的内容基本相似，在此也推荐给各位。")]),t._v(" "),r("h3",{attrs:{id:"源码大纲"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码大纲"}},[t._v("#")]),t._v(" 源码大纲")]),t._v(" "),r("p",[t._v("针对于VueRouter的源码分析，其实可以分为两部分来分析，或者说大部分的Vue插件都可以按照这样的方式去区分：安装插件的install方法和插件本身实例(Class)的实现。")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("install方法")]),t._v("\n在install方法中的操作其实可以分为三部分：\n"),r("ol",[r("li",[t._v("封装了一个mixin")]),t._v(" "),r("li",[t._v("注册了两个全局组件")]),t._v(" "),r("li",[t._v("定义了两个原型属性")])])]),t._v(" "),r("li",[r("strong",[t._v("插件类的实现")]),r("br"),t._v("\n每一个插件类的实现，其代码内容是相当庞大的，必须借助拆分的方法继续进行拆分，才有继续学下去勇气。\nVueRouter类的实现可以先分为两部分，之后再细分，这两份的内容：\n"),r("ol",[r("li",[t._v("VueRouter的构造函数(constructor)\n1.1. 初始化路由钩子队列\n1.2. 初始化matcher用于处理路由匹配逻辑并创建了路由对象\n1.3. 初始化history用于执行过渡逻辑并执行钩子队列")]),t._v(" "),r("li",[t._v("VueRouter的路由切换逻辑的执行(首次执行)"),r("br"),t._v("\n2.1. init方法中调用history对象的transitionTo方法\n2.2. 在transitionTo方法中通过Router实例的match方法获取当前路由匹配的数据并赋值给一个新对象route\n2.3. 把route传递给confirmTransition方法，执行钩子队列中的事件\n2.4. 在confirmTransition的成功回调函数中，更新current对象，引起被响应式化的_route更新从而触发组件重新渲染，\n2.5 调用ensureURL触发各自模式的路由更新方法，切换切面")]),t._v(" "),r("li",[t._v("路由的页面切换(非首次执行)\n3.1 在各自模式的push、replace、back等可以改变页面路由的方法，都是先调用transitionTo方法，然后在其成功回调函数中调用各自模式的更新路由的方法(pushHash、pushState)")])])])])])}),[],!1,null,null,null);n.default=o.exports}}]);